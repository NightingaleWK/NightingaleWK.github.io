{
    "version": "https://jsonfeed.org/version/1",
    "title": "雪漫城的风宅 • All posts by \"事件\" tag",
    "description": "この世界は好都合に未完成 だから知りたいんだ —— チ。-地球の運動について-",
    "home_page_url": "https://nightingalewk.cn",
    "items": [
        {
            "id": "https://nightingalewk.cn/2022/11/24/48.%20laravel%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E6%98%8E%E7%A4%BA%E4%BE%8B/",
            "url": "https://nightingalewk.cn/2022/11/24/48.%20laravel%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E6%98%8E%E7%A4%BA%E4%BE%8B/",
            "title": "laravel 事件系统简明示例",
            "date_published": "2022-11-24T08:17:00.000Z",
            "content_html": "<p>简单对 laravel 事件系统做一些说明</p>\n<span id=\"more\"></span>\n<p>laravel 的事件提供了一个简单的观察者实现，能够订阅和监听应用中发生的各种事件。事件类保存在 app&#x2F;Events 目录中，而这些事件的的监听器则被保存在 app&#x2F;Listeners 目录下。这些目录只有当你使用 Artisan 命令来生成事件和监听器时才会被自动创建。</p>\n<p>事件机制是一种很好的应用解耦方式，因为一个事件可以拥有多个互不依赖的监听器。例如，如果你希望每次订单发货时向用户发送一个 Slack 通知。你可以简单地发起一个 OrderShipped 事件，让监听器接收之后转化成一个 Slack 通知，这样你就可以不用把订单的业务代码跟 Slack 通知的代码耦合在一起了。</p>\n<h2 id=\"生成一个事件类\"><a href=\"#生成一个事件类\" class=\"headerlink\" title=\"生成一个事件类\"></a>生成一个事件类</h2><p>比如通过 artisan 命令生成一个 UserLogin 事件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php artisan make:event UserLogin</span><br></pre></td></tr></table></figure>\n<p>在 app&#x2F;Events 中就会自动生成一个 UserLogin.php 文件，内容不多，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"></span><br><span class=\"line\">namespace App\\Events;</span><br><span class=\"line\"></span><br><span class=\"line\">use Illuminate\\Broadcasting\\Channel;</span><br><span class=\"line\">use Illuminate\\Queue\\SerializesModels;</span><br><span class=\"line\">use Illuminate\\Broadcasting\\PrivateChannel;</span><br><span class=\"line\">use Illuminate\\Broadcasting\\PresenceChannel;</span><br><span class=\"line\">use Illuminate\\Broadcasting\\InteractsWithSockets;</span><br><span class=\"line\">use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;</span><br><span class=\"line\"></span><br><span class=\"line\">class UserLogin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    use InteractsWithSockets, SerializesModels;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create a new event instance.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return void</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public function __construct()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Get the channels the event should broadcast on.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return Channel|array</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public function broadcastOn()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new PrivateChannel(&#x27;channel-name&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义监听器\"><a href=\"#定义监听器\" class=\"headerlink\" title=\"定义监听器\"></a>定义监听器</h2><p>一个事件可以被一个或多个监听器监听，也就是观察者模式，我们可以定义多个监听器，当这个事件发生，执行一系列逻辑。</p>\n<p>在 EventServiceProvider 的 $listen 中可以定义事件和监听器，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected $listen = [</span><br><span class=\"line\">    &#x27;App\\Events\\UserLogin&#x27; =&gt; [</span><br><span class=\"line\">        &#x27;App\\Lisenter\\DoSomething1&#x27;,</span><br><span class=\"line\">        &#x27;App\\Lisenter\\Dosomething2&#x27;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>然后执行 artisan 命令，就可以自动在 app&#x2F;Lisenter 目录生成监听器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php artisan event::generate</span><br></pre></td></tr></table></figure>\n<p>可以看到 app&#x2F;Lisenter 目录多了 DoSomething1.php 和 DoSomething2.php 两个文件，我们看看其中一个内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"></span><br><span class=\"line\">namespace App\\Lisenter;</span><br><span class=\"line\"></span><br><span class=\"line\">use App\\Events\\UserLogin;</span><br><span class=\"line\">use Illuminate\\Queue\\InteractsWithQueue;</span><br><span class=\"line\">use Illuminate\\Contracts\\Queue\\ShouldQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">class DoSomething1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Create the event listener.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return void</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public function __construct()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Handle the event.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param  UserLogin  $event</span><br><span class=\"line\">     * @return void</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public function handle(UserLogin $event)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        info(&#x27;do something1&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在两个监听器的 handle 方法中我们打印一个日志来测试一下，如代码 handle 方法所示。</p>\n<h2 id=\"分发和触发事件\"><a href=\"#分发和触发事件\" class=\"headerlink\" title=\"分发和触发事件\"></a>分发和触发事件</h2><p>我们在某个控制器的方法中来分发事件，也就是触发事件，看监听器是否正常工作。</p>\n<p>就是一句话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event(new UserLogin());</span><br></pre></td></tr></table></figure>\n<p>然后我们请求这个控制器，观察日志，发现打印了日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2018-06-17 10:04:29] local.INFO: do something1</span><br><span class=\"line\">[2018-06-17 10:04:29] local.INFO: do something2</span><br></pre></td></tr></table></figure>\n<p>那么这个事件 - 监听机制就正常工作了。</p>\n<h1 id=\"队列异步处理\"><a href=\"#队列异步处理\" class=\"headerlink\" title=\"队列异步处理\"></a>队列异步处理</h1><p>如果某个监听器需要执行的操作比较慢，可以放到消息队列进行异步处理。</p>\n<p>比如把上面的 DoSomething1 改成需要放入队列的，只需要 implements ShoulQueue 接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DoSomething1 implements ShouldQueue</span><br></pre></td></tr></table></figure>\n<p>也可以指定队列驱动，如下代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 任务应该发送到的队列的连接的名称</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @var string|null</span><br><span class=\"line\"> */</span><br><span class=\"line\">public $connection = &#x27;redis&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 任务应该发送到的队列的名称</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @var string|null</span><br><span class=\"line\"> */</span><br><span class=\"line\">public $queue = &#x27;listeners&#x27;;</span><br></pre></td></tr></table></figure>\n<p>我们再次执行控制器方法。</p>\n<p>日志里没有打印 do something1，只有 do something2，但是在 redis 队列里发现了一个名为 queues:default 的列表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;job&quot;:&quot;Illuminate\\\\Events\\\\CallQueuedHandler@call&quot;,&quot;data&quot;:&#123;&quot;class&quot;:&quot;App\\\\Listener\\\\DoSomething1&quot;,&quot;method&quot;:&quot;handle&quot;,&quot;data&quot;:&quot;a:1:&#123;i:0;O:20:\\&quot;App\\\\Events\\\\UserLogin\\&quot;:1:&#123;s:6:\\&quot;socket\\&quot;;N;&#125;&#125;&quot;&#125;,&quot;id&quot;:&quot;3D7VDUwueYGtUvsazicWsifwWQxnnLID&quot;,&quot;attempts&quot;:1&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候需要使用 php artisan queue:work 执行队列任务，才是真正执行 DoSomething1 这个监听器的 handle 方法。</p>\n",
            "tags": [
                "事件"
            ]
        }
    ]
}